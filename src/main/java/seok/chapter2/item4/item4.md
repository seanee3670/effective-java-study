# 인스턴스화를 막으려거든 private 생성자를 사용하라

## 인스턴스화를 안하고 싶을때
클래스의 메서드를 호출하려면 크게 두가지 방법이 있다.
1) 인스턴스를 생성하여 클래스 메서드를 호출하는 방법.
2) 클래스의 메서드를 static 으로 선언하여 굳이 클래스를 인스턴스화 하지 않아도 메서드를 호출할 수 있는 방법.

가장 대표적인 예시가 import java.util 하여 사용하는 유틸리티 클래스이다.
예를 들어, 배열을 정렬할때 우리는 유틸클래스를 인스턴스화 하지 않고 메서드를 바로 호출한다.
아니, '호출하지 않는것이 맞다' 가 더 정확한 표현이겠다.

그렇다면, 인스턴스화를 막는 방법이 뭐가 있을까?

## 추상 클래스
추상클래스는 본디 상속을 위해 존재하는 클래스이며, 그렇기에 추상클래스 자체를 인스턴스화하는 것을 막아놨다.
이를 이용해서 클래스를 추상클래스로 만든다면 인스턴스화를 막을 수 있다는 이야기가 된다.
```java
public abstract class Chusang {
  public static void main(String[] args) {
    Chusang chusang = new Chusang(); // 컴파일 에러
  }
}
```

표면상으론 그렇다.

혹시나 만약 누군가 인스턴스화를 막기 위해 만든 추상클래스를 상속받는 자식클래스를 만든다면,
인스턴스화 과정에서 부모클래스 생성자를 호출하게 된다. 애초에 추상클래스는 인스턴스화 방지를 존재하는것이 아니기에,
상속을 장려해버리는 오해를 낳을 수 있다.

## private 생성자
이전 아이템들에서도 봤듯이, 생성자의 접근제어자를 `private`로 선언해주면 바깥 클래스에선 접근이 불가하다.
하지만, 클래스 내부에서도 접근을 막고 싶다면 `AssertionError`를 던지는 식으로 막을 수 있다.
또한, 사용되지 말아야할 코드에 대해 주석을 달아준다면 더욱 의도가 분명해질 것이다.
```java
public class Elvis {

  /**
      이 클래스는 인스턴스화 할 수 없습니다.
   */
  private Elvis() { // 외부클래스에서 접근 불가
    throw new AssertionError(); // 런타임으로 에러 발생시킴
  } 
  
  public static void leaveTheBuilding() { ... }
}
```


